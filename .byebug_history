q
@board
c
@board.tied?
@board.won?
q
@board.tied?
@board.tied
@board.won?
c
q
rows
pretty_rows
c
q
c
pretty_rows
q
    end
      end
        (idx_1 + 1) * (idx_2 + 1) if mark.nil?
      row.each_with_index.map do |mark, idx_2|
  pretty_rows = @board.rows.each_with_index.map do |row, idx_1|
@board
q
[0,0]
q
@mark
q
n
q
p pretty_rows
pretty_rows
q
yo.each.map { |num| num + 1 }
yo = [1,2,3]
@rows
q
input[3].to_i
input[3]
input
q
@board
board
q
winner.nil?
winner
q
triple == [:x, :x, :x]
triple
q
won?
tied?
q
board.game_over?
board
q
n
s
diagonals
cols
rows
self.rows
@rows
rows
@rows
rows
q
col
row
s
row
pos
q
la
yo
yo, la = [1,2]
pos
mark
pos
po
col
row
n
q
pos
s
col_coord
row_coord
board[0]
board
board[row_coord]
board
random_coord
board
q
pos
q
@board
q
unmarked_coords
q
@computer_player
@computer
@human_player
q
@board
@current_player
q
@human_player.mark
q
@human_player.mark
@human_player
q
@human_player.class.name
@human_player.class
@human_player
:o.to_s
@computer_player
@human_player
quit
q
"O".downcase
"O".lowercase()
"O".lowercase
Array.new(3) { Array.new(3) }
Array.new(3)
a = [[]] * 3
a
a = [] * 3
@board
